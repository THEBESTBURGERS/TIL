# 210623TIL

- 백준 while문 문제풀이 3개
- 자바스크립트 함수..
- 자바스크립트 클래스..
- 문제가 안풀릴듯 풀리네 ㅠ 뚝딱풀렸으면 좋겠는뎅 12시 되기전에 아슬아슬하게 커밋 !!
- 이제 어몽어스 하러갈래 ㅋㅋ

### 오늘 배운 것 중에 중요한 것!!

- user의 버전을 upgrade 시키는 함수를 작성할때  함수 내부 조건문에서 조건이 일치하면 복잡한 것을 실행 보다 조건이 부합하면 패스 이런식으로 코드 짜는게 훨씬 좋은 코드이다. 

```jsx
// bad
function upgradeUser(user){
    if(user.point > 10){
        // long upgrade logic...
    }
}
// good
function upgradeUser(user){
    if(user.point <= 10){
        return;
    }
    // long upgrade logic...-
}
```

- Getter와 Setter

```jsx
// 2. Getter and setters
class User {
    constructor(firstName, lastName, age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
    get age() {
        return this._age;
    }
    set age(value) {
        this._age = value < 0 ? 0 : value;
    }
}
const user1 = new User('Steve', 'Job', -1);
console.log(user1.age);

출처 : 댓글 Caleb Choi (https://www.youtube.com/watch?v=_DLhUBWsRtw)

조금 더 설명드리자면, class 내에 getter 와 setter 가 specifically define 되어있다면
그 define 되어있는 property 에 한해서 accessor로 작용합니다.
그래서 위에 예제에서 age 에 대한 getter / setter 가 정확하게 define이 되어있기 때문에,
이제 저 "User" object에서의 age를 access 하려고하면
자동으로 JS가 getter / setter를 call 합니다.

그래서 this.age = age; 에서 'this.age =' 는 set age(value)를 call 합니다.

그러면 이제 여기 set age()을 보시면
set age(value){
    this.age = value;
}
set age가 처음에 호출되고 function body를 execute할때,
this.age = value; 여기서 "this.age = " 는 다시 set age(value)를 호출하고,
다시 호출된 set age 에서 "this.age = "는 또 다시 set age(value)를 호출하고..
infinite recursion이 되서 callstack overflow 에러가 발생하죠.

그래서 나온 방법이 private property convention을 이용해서
getter 와 setter 안에 따로 age를 다른 이름으로 사용하자고 해서 _age로 define해줍니다.

set age(value){
    this._age = value;
}
그러면 이제 다시 constructor 로 돌아가서,
this.age = age; 이 실행될때 "this.age = "는 set age()를 호출하고,
set age()의 body에서보면 실제로는 age가 아니라 _age 라는 또 다른 이름의 변수에 저장합니다.
여기서 _age는 setter 가 define되어있지 않기 때문에 바로 메모리에 _age의 값을 저장합니다.
실제로는 _age라는 변수가 저장된 것이기 때문에, User object에서 age가 아닌 _age도
직접 access해보면 age랑 같은 값인 것을 볼 수 있습니다.
const user1 = new User('Java', 'Script', 10);
console.log(user1.age);
console.log(user1._age);
하면 둘다 같은 10이 나옵니다.

실제로는 age가 아니라 _age에 저장되었는데 왜 user1.age 도 10이 나오냐?  
위에서도 설명했듯이 자동으로 getter를 호출하기때문에 getter에서 우리가 _age 값을
return하기로 정의를 바꾸어 주었기때문에 user1.age 도 10을 리턴하는 것입니다.

그래서 위의 엘리님의 13:19 예제는 사실상 깊이 들어가서 메모리 레벨까지 보게되면,
age 는 실제로 undefined이고 _age 가 -1입니다.
하지만 외부 코드가 user1의  object를 access 할때는 age가 아니라
_age로 re-direct되기 때문에 high level에서 볼때 user1.age이 문제없이 -1로 작용하게되죠.
외부에는 불필요한 정보를 숨기는 것이고 이게 바로 encapsulation이죠.
```

: